[toc]

# 线程之间的通信

线程通信之前

## synchronized

```Java
package com.mofeng.thread.signal;

public class Demo {
    private volatile int signal;

    public void set(int value) {
        this.signal = value;
    }

    public int get() {
        return signal;
    }

    public static void main(String[] args) {
        Demo d = new Demo();
        new Thread(()->{
            System.out.println("修改状态的线程执行。。。");

            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            d.set(1);
            System.out.println("状态值修改成功。。。 ");
        }).start();

        new Thread(()->{
            //等待signal为1的时候开始执行，否则不能执行
            while (d.get()!=1){
                try {
                    //如果不休眠，一直抢占CPU资源，这样会好一些，但是会等待<1000ms时间
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("模拟代码的执行。。。");
            //当信号为1的时候，执行代码
        }).start();
    }
}
```

线程通信之后，解锁后立即执行

```Java
package com.mofeng.thread.signal;

public class Demo {
    private volatile int signal;

    public void set(int value) {
        this.signal = value;
    }

    public int get() {
        return signal;
    }

    public static void main(String[] args) {
        Demo d = new Demo();
        new Thread(()->{
            synchronized (d) {
                System.out.println("修改状态的线程执行。。。");
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                d.set(1);
                System.out.println("状态值修改成功。。。 ");
                d.notify();
            }
        }).start();

        new Thread(()->{
            //等待signal为1的时候开始执行，否则不能执行
            synchronized (d) {
                while (d.get() != 1) {
                    try {
                        d.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                //当信号为1的时候，执行代码
                System.out.println("模拟代码的执行。。。");
            }
        }).start();
    }
}
```

* wait和notify必须放在同步代码块中执行
* 调用notify的时候随机叫醒一个，调用notifyAll的时候全部叫醒
* 调用wait的时候会释放锁。调用notify的时候会拿到锁，同步代码块执行完毕之后线程醒来

**下面就是一个活生生的例子**

```java
package com.mofeng.thread.signal;

import java.util.concurrent.TimeUnit;

public class Demo {
    private volatile int signal;

    public synchronized void set() {
        this.signal = 1;
        notifyAll();
        //已唤醒全部线程，等待线程执行
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public synchronized int get() {
        System.out.println(Thread.currentThread().getName()+":方法执行了。。。");
        if (signal!=1){
            try {
                wait();
                //Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(Thread.currentThread().getName()+":方法执行完毕了。。。");
        return signal;
    }

    public static void main(String[] args) {
        Demo d = new Demo();

        Thread t1 = new Thread(()->{
            d.set();
        });
        Thread t2 = new Thread(()->{
            d.get();
        });
        Thread t3 = new Thread(()->{
            d.get();
        });
        Thread t4 = new Thread(()->{
            d.get();
        });
        t2.start();
        t3.start();
        t4.start();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(t1).start();
    }
}
```

# Condition

可以确定性的通知唤醒那个线程，leedcode第1114题

* condition是ReentrantLock的内部实现类
* 一个condition对应一个信号
* condition.await()相当于wait()
* condition.signal()相当于notify()，不过是唤醒condition

```Java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class Foo {

    private volatile int signal = 0;
    Lock lock = new ReentrantLock();
    Condition a = lock.newCondition();
    Condition b = lock.newCondition();
    
    public Foo() {

    }

    public void first(Runnable printFirst) {
        lock.lock();
        // printFirst.run() outputs "first". Do not change or remove this line.
        printFirst.run();
        signal++;
        a.signal();
        lock.unlock();
    }

    public void second(Runnable printSecond) {
        lock.lock();

        while (signal != 1) {
            try {
                a.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        // printSecond.run() outputs "second". Do not change or remove this line.
        printSecond.run();
        signal++;
        b.signal();
        lock.unlock();
    }

    public void third(Runnable printThird) {
        lock.lock();
        while (signal != 2) {
            try {
                b.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        // printThird.run() outputs "third". Do not change or remove this line.
        printThird.run();
        signal++;
        lock.unlock();
    }
}
```

# join

具体的应用场景暂时没有遇到

```java
public class DemoOfJoin {

    public void a(Thread joinThread){
        System.out.println("a开始执行了");
        try {
            joinThread.start();
            joinThread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("a执行结束");
    }

    public void b(){
        System.out.println("b已经执行了");
    }


    public static void main(String[] args) {
        DemoOfJoin d = new DemoOfJoin();

        Thread t1 = new Thread(()->{
            System.out.println("加塞线程开始执行了");
            d.b();
            System.out.println("加塞结束执行了");
        });

        new Thread(()->{
            System.out.println("t2开始执行了");
            d.a(t1);
            System.out.println("t2结束执行了");
        }).start();
    }
}
```

* 只有线程start()之后join()才有效
* 加塞线程执行结束之后唤醒当前线程

# CountDownLatch

等所有线程都到了countdown()的时候再接着执行