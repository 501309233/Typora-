[toc]

## 业务数据的特殊性

### 作为缓存使用

1. 原始业务功能设计
   * 秒杀
   * 618活动
   * 双11活动
   * 排队购票
2. 运营平台监控到的突发高频访问数据
   * 突发时政要闻，被强势关注围观
3. 高频、复杂的统计数据
   * 在线人数
   * 投票排行榜

### 附加功能

系统功能优化或升级

* 单服务器升级集群
* Session管理
* Token管理

## Redis数据类型(5种常用)

* string			String
* hash		HashMap
* list             LinkedList
* set                 HashSet
* sorted_set          TreeSet

## redis数据存储格式

* redis自身是一个Map，其中所有的数据都是采用key:value的形式存储
* 数据类型指的是存储的数据的类型，也就是value部分的类型，key部分永远都是字符串

## string类型和基本操作

* 存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型

* 存储数据的格式：一个存储空间保存一个数据

* 存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用

* 基本操作

  * 添加/修改数据：set key value
  * 获取数据：get key
  * 删除数据：del key
  * 添加/修改多个数据：mset key1 value1 key2 value2 ....
  * 获取多个数据：mget key1 key2
  * 获取数据字符个数（字符串长度）strlen key
  * 追加信息到原始信息后部（如果原始信息存在就追加，否则新建）：append key value

* string类型数据的扩展操作

* 业务场景：大型企业级应用中，分表操作是基本操作，使用多张表存储同类型数据，但是对应的主键id必须保证统一性，不能重复，Oracle数据库具有sequence设定，可以解决该问题，但是MySQL数据库并不具有类似的机制，如何解决呢？

  * 问题：多个表，ID统一不重复
  * 解决方案：
    * 设置数值数据增加指定范围的值
      * incr key
      * incrby key increment
      * incrbyfloat key increment
    * 设置数值数据减少指定范围的值
      * decr key 
      * decrby key increment
  * string作为数值操作
    * string在redis内部存储默认就是一个字符串，当遇到增减类操作incr，decr时回转成数值型进行计算
    * redis所有操作都是原子性的，采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响
    * 注意：按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis数值上的范围，将报错（Lone.MAX_VALUE）
  * redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性
  * 此方案适用于所有数据库，且支持数据库集群

* 业务场景：“最强女生”启动海选投票，只能通过微信投票，每个微信号每4小时只能投1票。电商商家开启热门商品推荐，热门商品不能一直处于热门期，美中商品热门维持3天，3天后自动取消热门

  * 解决方案：

    * 设置数据具有指定的生命周期(过了时常自动变空)

      setex key seconds value

      pseted key milliseconds value

  * redis控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作

### string类型数据操作的注意事项

* 数据操作不成功的反馈与数据正常操作之间的差异

  * 表示运行结果是否成功

    * (integer)0---false
    * (integer)1---true

  * 表示运行结果值

    * (integer)3---3.  3个
    * (integer)1---1.  1个

  * 数据未获取到

    (nil)等同于null

  * 数据最大存储量

    512MB

  * 数值计算最大范围(Long.MAX_VALUE)

* 业务场景：主页高频访问信息显示控制，例如新浪微博大V主页显示粉丝数

  * 解决方案

    在redis中为大V用户设定用户信息，以用户主键和属性值作为key，后台设定定时刷新策略即可

    eg: user: id:35​1121:fans 12312

    eg: user: id:351121:blogs 2131

    eg: user: id:351121:focuss 121

    在redis中以json格式存储大V用户信息，定时刷新（也可以使用hash类型）

    eg: user: id:351121 {id:351121,fans:12312,blogs:2131,focuss:121}

  * redis应用于各种结构型和非结构性高热度数据访问加速

### key的设置约定

* 数据库中的热点数据key命名惯例

  表名:主键名:主键值:字段名

  eg1:    order: id:21312:names





## hash类型

对象类数据的存储如果具有较频繁的更新需求操作会显得笨重

* 新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息
* 需要的存储结构：一个存储空间保存多个键值对数据

存储结构：

​		key-->{field1:value1.  field2:value2}

### hash存储结构优化

* 如果field数量较少，存储结构优化为类数组结构
* 如果field数量较多，存储结构使用HashMap结构

### hash类型数据的基本操作

* 添加/修改数据

  hset key field value

* 获取数据

  hget key field

  hgetall key

* 删除数据

  hdel key field1 [field2]

* 添加/修改多个数据

  hmset key field1 value1 field2 value2 ...

* 获取多个数据

  hmget key field1 field2

* 获取哈希表中字段的数量

  hlen key

* 获取哈希表中是否存在指定的字段

  hexists key field

### hash类型数据扩展操作

* 获取哈希表中所有的字段名或字段值

  hkeys key

  hvals key

* 设置指定字段的数值数据增加指定范围的值

  hincrby key field increment

  hincrbyfloat key field increment

### hash类型数据操作的注意事项

* hash类型下的value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据未获得到，对应的值为(nil)
* 每个hash可以存储2^32-1个键值对
* hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性，但hash设计初衷不是为了存大量对象而设计的，切记不可滥用，更不可以、将hash作为对象列表使用
* hgetall操作可以获取全部属性，如果内部field过多，遍历整体数据效率就会很低，有可能成为数据访问瓶颈

### hash类型应用场景

* 业务场景：电商网站购物车设计与实现

* 业务分析

  * 仅分析购物车的redis存储模型：添加，浏览，更改数量，删除，清空

* 解决方案

  * 以客户id作为key，每位客户创建一个hash春初结构存储对应的购物车信息
  * 将商品编号作为field，购买数量作为value进行存储
  * 添加商品：追加全新的field与value
  * 浏览：遍历hash
  * 更改数量：自增/自减，设置value值
  * 删除商品：删除field
  * 清空：删除key

* 当前仅仅是将数据存储到了redis中，并没有起到加速的作用，所以

  * 每条购物车中的商品记录保存成两条field
  * field1专门用于保存购买数量，命名格式：商品id:nums
  * 独立hash专门用于保存购物车中显示的信息，包含文字描述，图片地址，所属商家信息等

  hsetnx key field value-->如果hash中key有值则什么都不做，无值则添加



* 业务场景
  * 双11活动日销售手机充值卡的商家对移动、联通、电信的30元、50元、100元商品推出抢购活动，每种商品抢购上限1000张
* 解决方案
  * 以商家id作为key
  * 将参与抢购的商品id作为field
  * 将参与抢购的商品数量作为对应的value
  * 抢购时使用降值的方式控制产品数量
  * 实际业务中还有超卖等实际问题，这里不讨论
* redis应用于抢购、限购类、限量发放优惠券、激活码等业务等数据存储设计







## String存储对象（json）与hash存储对象的区别



string数据讲究整体性，要么一次性更新要么一次性获取，讲究读为主

hash因为可以以field分割开，所以hash以更新为主



## list类型

* 数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分
* 需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序
* list类型：保存多个数据，底层使用双向链表存储结构实现（可以左添加，可以右添加）

## list类型数据的基本操作

* 添加/修改数据

  ```redis
  lpush key value1 [value2]... (左添加)
  rpush key value1 [value2]...（右添加）
  ```

* 获取数据

  ```
  lrange key start stop  #stop可以为负数，-1为最后一个
  lindex key index
  llen key 
  ```

* 获取并移除数据

  ```
  lpop key 
  rpop key 
  ```

* 移除指定数据

  ```
  lrem key count value  #删除key列表的count个value
  ```

  

## list类型数据扩展操作

* 规定时间内获取并移除数据

  ```
  blpop key1 [key2] timeout
  brpop key1 [key2] timeout
  ```

### 业务场景

* 微信朋友圈点赞，要求按照点赞顺序显示点赞好友信息
* Twitter，新浪微博等个人用户的关注列表需要按照用户的关注顺序进行展示，粉丝列表需要将最近关注的粉丝列在前面

redis应用于具有操作先后顺序的数据控制

redis应用于最新消息展示或全消息展示

### 解决方案

* 依赖list的数据具有顺序的特征对信息进行管理
* 使用队列模型解决多路信息汇总合并的问题
* 使用栈模型解决最新消息的问题

### list类型数据操作注意事项

* list中保存的数据都是string类型的，数据总容量是有限的，最多2^23-1个元素
* list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作，或以栈的形式入栈出栈操作
* 获取全部数据操作结束索引设置为-1
* list可以对数据进行分页操作，通常第一页的信息来自于list，第2页及更多的信息通过数据库的形式加载



## set类型

* 新的存储需求：存储大量的数据，在查询方面提供更高的效率
* 需要的存储结构：能够保存大量的数据，高效的内部存储机制，便于查询

* set类型：与hash存储结构完全相同，仅存储键，不存储值(nil)，并且值不允许重复

### set类型数据的基本操作

* 添加数据

  ```
  sadd key member1 [member2]
  ```

* 获取全部数据

  ```
  smembers key 
  ```

* 删除数据

  ```
  srem key member1 [member2]
  ```

* 获取集合数据总量

  ```
  scard key
  ```

* 判断集合中是否包含指定数据

  ```
  sismember key member
  ```

* 随机获取集合中指定数量的数据

  ```
  srandmember key [count]
  ```

* 随机获取集合中的某个数据并将该数据移出集合

  ```
  spop key 
  ```

### 业务场景

每位用户首次使用今日头条会设置3项爱好内容，但是后期为了增加用户的活跃度，兴趣点，必须让用户对其他信息类别逐渐产生兴趣，增加客户留存度，如何实现？

### 业务分析

* 系统分析出各个分类的最新或最热点信息条目并组织成set集合
* 随机挑选其中部分信息
* 配合用户关注信息分类中的热点信息组织成展示的全信息集合

redis应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热点旅游线路，应用app推荐等