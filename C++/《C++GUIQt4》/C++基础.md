[toc]

#C++入门

一个C++程序由一个或者多个编译单元（compilation unit）构成。每个编译单元都是一个独立的源代码文件，通常是一个带.cpp扩展名（其他常用的扩展名还有.cc和.cxx）的文件，编译器每次可以处理一个这样的文件。对于每一个编译单元，编译器都会产生一个目标文件，它的扩展名是.obj（这Windows中）或者.o（这Unix和macOS中）。这个目标文件是一个二进制文件，其中包含了系统架构方面的机器代码，而程序则要运行在此基础之上。

一旦所有的.cpp文件都已编译完成，那么我们就可以使用一个称为连接器的特殊程序，吧这些文件连接在一起，生成一个可执行程序。连接器会连接这些目标文件，并且会解析函数和编译单元中引用到的其他符号的内存地址。

在构建一个程序时，必须确保其中的某个编译单元包含一个main()函数，它是程序入口的标志。这个函数不属于任何类，它是一个全局函数(global function)。

C++可以按我们想要的形式组织各个编译单元。我们可以在同一个.cpp文件中实现多个类，或者也可以把一个类的实现分散到多个.cpp文件中，并且还可以把这些源文件命名为我们所喜欢的任意名字。当在某一个特殊的.cpp文件中进行修改时，只需要重新编译那个文件，然后再重新连接这个应用程序就可以生成一个新的可执行程序。

在C++中，main()函数的参数是一个int和一个char*数组（一个字符串数组）。可以从argv[0]中获取程序的名字，命令行参数则分别放在argv[1]、argv[2]...argv[argc-1]中，把参数命名为argc(argument count, 参数个数)和argv(argument value, 参数值)是一种习惯做法，如果这个程序不能使用命令行参数，那么可以把main()定义成不带参数的形式。

标准C++库中的所有函数和大多数的其他对象都是在std命名空间中。一种访问命名空间中的某一项的方法是用命名空间的名字和::操作符可以作为该项名字的前缀。在C++中，::操作符可以作为复杂名字的分隔符。命名空间可以使巨大的多人合作项目变得更容易些，因为命名空间可以避免命名冲突问题。

我们通常把函数的函数原型放在一个单独的文件中，然后在需要调用这个函数的所有编译单元中都包含那个文件。这样的文件就称为头文件（header file），并且通常带一个.h扩展名（常见的还有.hh,.hpp,.hxx等），不像.cpp文件，这些头文件自身都不是编译单元，并且也不会产生任何目标文件。头文件或许只包含一些让不同的编译单元能够互相联系的声明而已。因此，把函数的实现代码放在一个头文件中就显得不合适了。

可执行程序通常会连接许多库，这些库可以实现许多现成的功能。库主要有两种类型：

* 静态库，可以直接放进可执行程序，就好像他们是一些目标文件一样。这可以确保不会弄丢这些库，但却会让可执行程序变得很大。
* 动态库（也称共享库或DLL）位于用户机器上的标准位置，并且会在应用程序启动的时候自动加载他们。

通常大多数平台都是采用动态库的形式实现。Qt自身就是一个库的集合，既可编译为静态库又可编译为动态库（默认动态库）

# C++语言特点

## 类定义

* 类定义可以划分为public、protected和private三段，且以一个分号结束。如果没有定义段，那么就默认是private段。（为了保持与C的兼容性，C++提供了一个struct关键字，除了在没有指定段时它的默认段是public这一点不同外，其他都与类相同）
* 类有两个构造函数（一个没有参数，一个则有两个参数）。我们没有声明构造函数，那么C++将会自动提供一个不带参数的构造函数，并且这个构造函数的函数体为空。
* 用来获取值的函数x()和y()声明为const。这就意味着它们不会（而且也不能）修改成员变量或者调用非const成员函数[比如setX()]

* 在C++中，任意类型的变量都可以直接声明而不必一定要使用new。
* C++作为一种面向对象的语言，支持继承和多态。
* C++支持保护继承和私有继承，利用它们可以限制对基类public成员和protected成员对访问。，通过public方式继承基类表明基类中所有公有成员在子类中仍旧是公有的。
* 如果需要调用一个函数的基本实现，可以在这个函数名字前加上一个由基类的名字和“::”操作符构成的前缀，如：Circle::draw();
* C++支持多重继承，一个类可以同时从多个类中派生出来，如 

```c++
class DerivedClass : public BaseClass1,public BaseClass2,...,public BaseClassN{};
```

* 默认情况下，类中声明的函数和变量都与这个类的实例相关。我们也可以声明静态(static)成员函数和静态成员变量，可以在没有实例的情况下使用它们。

```c++
#ifndef TRUCK_H
#define TRUCK_H

class TRUCK
{
public:
  //构造函数
		Truck(){++counter;}
  //析构函数
		~Truck(){--counter;}
		static int instanceCount(){return counter;}
private:
		static int counter;
 //通过这里的静态成员变量counter，我们可以在任何时候知道还存在多少个Truck实例
};
#endif
```

* 一个静态成员变量在一个类中只有单一的存在实体：这样的变量就是“类变量”而不是“实例变量”。每一个静态成员变量都必须定义在.cpp文件（但是不能再次重复static关键字）。例如：

  ```c++
  #include "truck.h"
  int Truck::counter = 0;
  ```

  只要把类名作为前缀，就可以在该类外面访问这个instanceCount()静态函数。例如

  ```c++
  #include <iostream>
  #include "truck.h"
  
  int main()
  {
  	Truck truck1;
  	Truck truck2;
  	std::cout<<Truck::instanceCount()<<" equals 2"<<std::endl;
  	return 0;
  }
  ```

  ## 指针

* 指针(pointer)就是一个可以存储对象的内存地址的变量(而不是直接存储这个对象)。

  指针的语法是在变量名的前面加上一个星号。 `Point2D *ptr`，由于没有初始化这个指针，所以它包含的是一个随机的内存地址值。可以给这个指针分配其他对象的地址解决初始化问题，`ptr = &alpha`这里的一元运算符"&"可以返回一个对象的内存地址值。地址值通常是一个32位或者一个64位的整型值，可以用来确定一个对象在内存中的偏移量。

  然后我们可以通过ptr这个指针来访问alpha这个对象。因为ptr是指针而不是对象，所以必须使用"->"操作符来代替"."操作符
  `prt=0`把这个指针设置为空指针。C++没有一个可以用于表示不指向对象指针的关键字。所以我们该换用0（或者是符号常量NULL，它可以扩展为0）来代替。试图使用一个空指针会造成系统的崩溃，提示的错误信息有"Segmentation fault（段错误）、"General protection fault(常规保护错误)"、或"Bus error（总线错误）"等。使用程序调试器，可以找出哪一行代码造成系统的崩溃。

* 指针通常用于存储使用new动态分配的对象。在C++术语中，这样的对象称为是分配在“堆”（heap）上，而局部变量（在一个函数中定义的变量）则存储在“栈”（stack）里。

  ```c++
  #include "point2d.h"
  int main()
  {
  	Point2D *point = new Point2D;
    //new操作符返回一个新近分配对象的内存地址，我们把这个地址存储在一个指针变量中，通过这指针访问该对象。处理完这个对象后，使用delete操作符释放内存。
  	point->setX(1.0);
  	point->setY(2.5);
  	delete point;
  	return 0;
  }
  ```

* 如果忘记调用delete，内存就会一直保留到该程序结束时为止。严重时会将机器的内存耗尽。对象一旦删除，指向该对象的指针变量仍旧会保存这个对象的地址值。这样的指针就称为“悬摆指针”(dangling pointer)，最好不要再使用这样的指针访问该对象。Qt提供了一种“智能“smart指针 `QPointer<T>`，如果删除了它所指向的`QObject`对象，那么它就会自动把自己设置成0.

  使用带参构造函数：`Point2D *point = new Point2D(1.0,2.5);`

  当然，最好使用下面的例子在栈上分配该对象，不需要使用new和delete：

  ```c++
  Point2D point;
  point.setX(1.0);
  point.setY(2.5);
  //这样分配的对象会在出现它们的程序块的末位自动得到释放
  ```

* 如果不打算通过该指针来修改这个对象，则可以把指针声明为const型指针。例如：

  ```c++
  const Point2D *ptr = new Point2D(2.0,2.5);
  double x=ptr->x();
  double y=ptr->y();
  
  //因为不能通过指针修改对象，所以下面的程序不可编译
  ptr->setX(4.3);
  *ptr = Point2D(4.3,1.3);
  ```

  这个常量指针ptr只能用于调用常量成员函数，比如x()和y()。当不打算使用指针修改它们时，把指针声明为const是一种不错的习惯。如果该对象自身就是常量，那么只能使用常量指针来存储它的地址值。

  const的用法可以为编译器提供一定的信息，这可以提早发现一些bug，并且也可以获得良好的性能。

* 箭头运算符“->“可用于通过指针来访问对象的成员，除了ptr->member的形式外，还可以使用(*ptr).member的形式。这里的圆括号是必需的。

## 引用

和指针一样，一个C++的引用存储的也是一个对象的地址值，两者的不同主要不同点在于：

* 声明引用时使用的是“&”而不是“*”
* 引用必须是初始化过的，并且不能在后面再次重新赋值。
* 可以直接访问与引用相关联的对象，且没有像“*”或者“->”这样的特殊语法。
* 引用不能为空(null)

对于大多数类型来讲，C++会使用按值调用的方式来作为它的默认参数传递机制。也就是说，当给一个函数传递参数的时候，该函数会接收到这个对象的一个新的副本

