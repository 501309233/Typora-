[toc]





## 一、基础能力面试

### 1、HashMap的实现机构原理，Java8对HashMap的机构做了哪些优化

https://blog.csdn.net/weixin_41719737/article/details/83551954

补充：

​	X.equals(Y)=true则他们的hashcode应当相同，如果两个对象的hashcode相同，它们并不一定相同

### 2、java线程池中coreSize,maxSize,queueLength,keepAliveTime,rejectStrategy那么多参数之间的联系和相互作用的影响是什么?

https://blog.csdn.net/aitangyong/article/details/38822505

**corePoolSize**：线程池的基本大小，即在没有任务需要执行的时候线程池的大小，并且只有在工作队列满了的情况下才会创建超出这个数量的线程

**maximumPoolSize**：线程池中允许的最大线程数，线程池中的当前线程数目不会超过该值

**poolSize**：线程池中当前线程的数量，当该值为0的时候，意味着没有任何线程，线程池会终止；同一时刻，poolSize不会超过maximumPoolSize

新提交一个任务时的处理流程很明显：
1、如果线程池的当前大小还没有达到基本大小(poolSize < corePoolSize)，那么就新增加一个线程处理新提交的任务；

2、如果当前大小已经达到了基本大小，就将新提交的任务提交到阻塞队列排队，等候处理workQueue.offer(command)；

3、如果队列容量已达上限，并且当前大小poolSize没有达到maximumPoolSize，那么就新增线程来处理任务；

4、如果队列已满，并且当前线程数目也已经达到上限，那么意味着线程池的处理能力已经达到了极限，此时需要拒绝新增加的任务。至于如何拒绝处理新增的任务，取决于线程池的饱和策略RejectedExecutionHandler。

通过corePoolSize和maximumPoolSize，控制如何新增线程；

通过allowCoreThreadTimeOut和keepAliveTime，控制如何销毁线程

**allowCoreThreadTimeOut**

该属性用来控制是否允许核心线程超时退出。If false,core threads stay alive even when idle.If true, core threads use keepAliveTime to time out waiting for work。如果线程池的大小已经达到了corePoolSize，不管有没有任务需要执行，线程池都会保证这些核心线程处于存活状态。可以知道：该属性只是用来控制核心线程的
**keepAliveTime**

如果一个线程处在空闲状态的时间超过了该属性值，就会因为超时而退出。举个例子，如果线程池的核心大小corePoolSize=5，而当前大小poolSize =8，那么超出核心大小的线程，会按照keepAliveTime的值判断是否会超时退出。如果线程池的核心大小corePoolSize=5，而当前大小poolSize =5，那么线程池中所有线程都是核心线程，这个时候线程是否会退出，取决于allowCoreThreadTimeOut。

### 3、java并发处理的方式有哪些?

问的基本都是，Java多线程的实现方式，线程安全方面，下面这个博客讲的非常详细

https://blog.csdn.net/a_blackmoon/article/details/79860114

### 4、jvm分为哪几个区，他们之间的关系如何，gc时会做哪些事情

#### 程序计数器PC

* 线程私有的
* 它可以看做是当前线程所执行的字节码的行号指示器
* 内存区域中唯一一个没有规定任何OutOfMemoryError的区域

#### Java虚拟机栈

* 线程私有的
* 每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息
* 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverFlowError异常；如虚拟机扩展时仍无法申请到足够的内存，就会抛出OutOfMemoryError异常

#### 本地方法栈

* 与虚拟机栈非常相似，区别是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用Native方法服务，也会抛出StackOverFlowError和OutOfMemoryError异常

#### Java堆

* 线程共享的
* Java堆是GC管理的主要区域
* 在虚拟机启动时创建
* 存放对象实例，几乎所有的对象实例和数组都在这里分配内存
* 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常

#### 方法区

* 线程共享的
* 用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据
* 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常

#### 运行时常量池（在方法区中）

* 是方法区的一部分
* 用于存放编译器生成的各种字面量和符合引用
* 相对于Class文件常量池的一个重要特征是，具备动态性
* 运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常

每一个区是干嘛的如下博客：

https://blog.csdn.net/ma345787383/article/details/77099262

https://blog.csdn.net/weixin_39046924/article/details/80443619

#### GC时会做哪些事情

1. 在什么时候GC

   GC堆内存分为三部分：Young Generation，Old Generation，Permanent Generation。Young Generation 分为：Eden , Survivor1 , Survivor2， 新创建的对象会分配在Eden区,在经历一次Minor GC后会被移到Survivor 1区，再经历一次Minor GC后会被移到Survivor 2区，直到升至老年代,需要注意的是，一些大对象(长字符串或数组)可能会直接存放到老年代；升到老年代的对象大于剩余空间时，会发生[Full GC](https://www.jianshu.com/writer#/notebooks/4879117/notes/16207262)，或者小于时，查看是否设置了XX:+HandlePromotionFailure(允许担保失败)参数，若允许，则只会进行Minor GC，此时可以容忍内存分配失败；若不允许，强制Full GC。GC与非GC时间耗时超过了GCTimeRatio的限制引发OOM，调优诸如通过NewRatio控制新生代老年代比例，通过MaxTenuringThreshold控制进入老年前生存次数等。
   
2. 对什么东西GC

   从GC root 开始搜索，搜索不到的对象和经过第一次标记、清理后仍旧没复活的对象，这类对象会被GC

3. GC做了什么事

   按照各部分的收集器进行空间回收，其中涉及到的收集器和GC算法参见另两篇文章：

   [收集器](https://www.jianshu.com/writer#/notebooks/4879117/notes/16207262) 和[GC算法](https://www.jianshu.com/writer#/notebooks/4879117/notes/16203704)。

   ​    新生代做复制清理、老年代做的是标记整理、标记清除

   参考链接：https://www.jianshu.com/p/a5fb04ff58c3

## 二、Javaweb的知识

### 1、http协议get和post的区别

#### （一）从HTTP报文来看

​	Get请求方式将请求信息放在URL后面，请求信息和URL之间以？隔开，请求信息的格式为键值对，例如：

[https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&rsv_idx=1&tn=baidu&wd=http%E5%8D%8F%E8%AE%AEget%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB&oq=G%2526lt%253B%25E6%2597%25B6%25E4%25BC%259A%25E5%2581%259A%25E5%2593%25AA%25E4%25BA%259B%25E4%25BA%258B%25E6%2583%2585&rsv_pq=e4503fff0000a682&rsv_t=dbf0XT9tpCcXdlo2OLM0kOANQJEUaHE39tTWepQIzcSmxI9rEGbLplOr6%2Fo&rqlang=cn&rsv_enter=1&rsv_dl=tb&rsv_sug3=1&rsv_sug2=0&inputT=639&rsv_sug4=639](https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&rsv_idx=1&tn=baidu&wd=http协议get和post的区别&oq=G%26lt%3B%E6%97%B6%E4%BC%9A%E5%81%9A%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85&rsv_pq=e4503fff0000a682&rsv_t=dbf0XT9tpCcXdlo2OLM0kOANQJEUaHE39tTWepQIzcSmxI9rEGbLplOr6%2Fo&rqlang=cn&rsv_enter=1&rsv_dl=tb&rsv_sug3=1&rsv_sug2=0&inputT=639&rsv_sug4=639)

这种请求方式将请求信息直接暴露在URL中，安全性较低，另外从报文结构来看，由于请求信息放置在URL中，因此请求报文中不需要报文体。

​	POST请求方式将请求信息放置在报文体中，相获得请求信息必须解析报文，因此安全性较GET方式要高一些（事实上要获得报文体中的请求信息也是很容易的，因此安全性上两者并没有太多的区别，具体解决传输过程中的安全性问题要靠HTTPS），此外在请求报文中含有报文体。

​	由于GET中的请求信息放置在URL中，因此是由长度限制的，因为URL本身是有长度限制的，POST中的请求信息是放置在报文体中，因此对数据长度是没有限制的

#### （二）从数据库层面来看

​	GET请求方式符合幂等性和安全性，（幂等性的定义：堆数据库的一次操作和多次操作获得的结果是一致的，则认为符合幂等性。安全性的定义：对数据库的操作没有改变数据库中的数据，则认为符合安全性），GET请求方式是做查询操作中间对数据库中的数据作了更改），从这来说是不符合幂等性的定义，但是因为GET请求只是查询数据库，不会对数据库做任何更改，因此也认为是幂等的。

​	POST请求方式是既不幂等又不安全，首先POST请求方式往数据库中提交数据，因此会改变数据库中的数据，其次，POST请求方式每次获得的结果都有可能不一样，因为POST请求是作用在上一级的URL上的，则每一次请求都会添加一份新资源（这也是POST和PUT方式的最大区别，PUT方式是幂等的）

**注意：在这里提到的安全性不同于上一部分，不要混淆**

#### （三）从其他层面来看

GET请求能够被缓存

GET请求会保存在浏览器的浏览记录中

以GET请求的URL能够保存为浏览器的书签

而POST方式都不具备上述功能。缓存也是GET请求被广泛应用的根本，在现代网络上每天产生的请求数目是巨大的，并且其中绝大部分请求均为只读请求，如果所有的这些请求都要交由Web服务器直接处理，这无疑是巨大的资源浪费。从第二部分知道GET表达的是一种幂等的、安全的，它除了返回结果不应该会产生其他副作用，因此绝大部分GET请求（通常超过90%）都直接被CDN缓存了，这能大大减少Web服务器的负担。而POST是非幂等的，有副作用的操作，所以必须交由Web服务器处理

