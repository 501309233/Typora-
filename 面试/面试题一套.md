[toc]

### 1、HashMap的实现机构原理，Java8对HashMap的机构做了哪些优化

https://blog.csdn.net/weixin_41719737/article/details/83551954

补充：

​	X.equals(Y)=true则他们的hashcode应当相同，如果两个对象的hashcode相同，它们并不一定相同

### 2、java线程池中coreSize,maxSize,queueLength,keepAliveTime,rejectStrategy那么多参数之间的联系和相互作用的影响是什么?

https://blog.csdn.net/aitangyong/article/details/38822505

**corePoolSize**：线程池的基本大小，即在没有任务需要执行的时候线程池的大小，并且只有在工作队列满了的情况下才会创建超出这个数量的线程

**maximumPoolSize**：线程池中允许的最大线程数，线程池中的当前线程数目不会超过该值

**poolSize**：线程池中当前线程的数量，当该值为0的时候，意味着没有任何线程，线程池会终止；同一时刻，poolSize不会超过maximumPoolSize

新提交一个任务时的处理流程很明显：
1、如果线程池的当前大小还没有达到基本大小(poolSize < corePoolSize)，那么就新增加一个线程处理新提交的任务；

2、如果当前大小已经达到了基本大小，就将新提交的任务提交到阻塞队列排队，等候处理workQueue.offer(command)；

3、如果队列容量已达上限，并且当前大小poolSize没有达到maximumPoolSize，那么就新增线程来处理任务；

4、如果队列已满，并且当前线程数目也已经达到上限，那么意味着线程池的处理能力已经达到了极限，此时需要拒绝新增加的任务。至于如何拒绝处理新增的任务，取决于线程池的饱和策略RejectedExecutionHandler。

通过corePoolSize和maximumPoolSize，控制如何新增线程；

通过allowCoreThreadTimeOut和keepAliveTime，控制如何销毁线程

**allowCoreThreadTimeOut**

该属性用来控制是否允许核心线程超时退出。If false,core threads stay alive even when idle.If true, core threads use keepAliveTime to time out waiting for work。如果线程池的大小已经达到了corePoolSize，不管有没有任务需要执行，线程池都会保证这些核心线程处于存活状态。可以知道：该属性只是用来控制核心线程的
**keepAliveTime**

如果一个线程处在空闲状态的时间超过了该属性值，就会因为超时而退出。举个例子，如果线程池的核心大小corePoolSize=5，而当前大小poolSize =8，那么超出核心大小的线程，会按照keepAliveTime的值判断是否会超时退出。如果线程池的核心大小corePoolSize=5，而当前大小poolSize =5，那么线程池中所有线程都是核心线程，这个时候线程是否会退出，取决于allowCoreThreadTimeOut。

### 3、java并发处理的方式有哪些?

问的基本都是，Java多线程的实现方式，线程安全方面，下面这个博客讲的非常详细

https://blog.csdn.net/a_blackmoon/article/details/79860114

### 4、jvm分为哪几个区，他们之间的关系如何，gc时会做哪些事情

#### 程序计数器PC

* 线程私有的
* 它可以看做是当前线程所执行的字节码的行号指示器
* 内存区域中唯一一个没有规定任何OutOfMemoryError的区域

#### Java虚拟机栈

* 线程私有的
* 每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息
* 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverFlowError异常；如虚拟机扩展时仍无法申请到足够的内存，就会抛出OutOfMemoryError异常

#### 本地方法栈

* 与虚拟机栈非常相似，区别是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用Native方法服务，也会抛出StackOverFlowError和OutOfMemoryError异常

#### Java堆

* 线程共享的
* Java堆是GC管理的主要区域
* 在虚拟机启动时创建
* 存放对象实例，几乎所有的对象实例和数组都在这里分配内存
* 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常

#### 方法区

* 线程共享的
* 用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据
* 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常

#### 运行时常量池（在方法区中）

* 是方法区的一部分
* 用于存放编译器生成的各种字面量和符合引用
* 相对于Class文件常量池的一个重要特征是，具备动态性
* 运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常

每一个区是干嘛的如下博客：

https://blog.csdn.net/ma345787383/article/details/77099262

https://blog.csdn.net/weixin_39046924/article/details/80443619

#### GC时会做哪些事情

1. 在什么时候GC

   首先，GC分为

