### 1、HashMap的实现机构原理，Java8对HashMap的机构做了哪些优化

https://blog.csdn.net/weixin_41719737/article/details/83551954

补充：

​	X.equals(Y)=true则他们的hashcode应当相同，如果两个对象的hashcode相同，它们并不一定相同

### 2、java线程池中coreSize,maxSize,queueLength,keepAliveTime,rejectStrategy那么多参数之间的联系和相互作用的影响是什么?

https://blog.csdn.net/aitangyong/article/details/38822505

**corePoolSize**：线程池的基本大小，即在没有任务需要执行的时候线程池的大小，并且只有在工作队列满了的情况下才会创建超出这个数量的线程

**maximumPoolSize**：线程池中允许的最大线程数，线程池中的当前线程数目不会超过该值

**poolSize**：线程池中当前线程的数量，当该值为0的时候，意味着没有任何线程，线程池会终止；同一时刻，poolSize不会超过maximumPoolSize

新提交一个任务时的处理流程很明显：
1、如果线程池的当前大小还没有达到基本大小(poolSize < corePoolSize)，那么就新增加一个线程处理新提交的任务；

2、如果当前大小已经达到了基本大小，就将新提交的任务提交到阻塞队列排队，等候处理workQueue.offer(command)；

3、如果队列容量已达上限，并且当前大小poolSize没有达到maximumPoolSize，那么就新增线程来处理任务；

4、如果队列已满，并且当前线程数目也已经达到上限，那么意味着线程池的处理能力已经达到了极限，此时需要拒绝新增加的任务。至于如何拒绝处理新增的任务，取决于线程池的饱和策略RejectedExecutionHandler。

通过corePoolSize和maximumPoolSize，控制如何新增线程；

通过allowCoreThreadTimeOut和keepAliveTime，控制如何销毁线程

**allowCoreThreadTimeOut**

该属性用来控制是否允许核心线程超时退出。If false,core threads stay alive even when idle.If true, core threads use keepAliveTime to time out waiting for work。如果线程池的大小已经达到了corePoolSize，不管有没有任务需要执行，线程池都会保证这些核心线程处于存活状态。可以知道：该属性只是用来控制核心线程的
**keepAliveTime**

如果一个线程处在空闲状态的时间超过了该属性值，就会因为超时而退出。举个例子，如果线程池的核心大小corePoolSize=5，而当前大小poolSize =8，那么超出核心大小的线程，会按照keepAliveTime的值判断是否会超时退出。如果线程池的核心大小corePoolSize=5，而当前大小poolSize =5，那么线程池中所有线程都是核心线程，这个时候线程是否会退出，取决于allowCoreThreadTimeOut。

### 3、java并发处理的方式有哪些?



