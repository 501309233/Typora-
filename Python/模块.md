[TOC]

# 模块

在“Python 函数”课程中介绍过函数的优点之一是可将代码与主程序分离，通过指定描述性名称，可以让主程序更加容易理解。还可以进一步升级操作，将函数存储在称为“模块”的独立文件中，再将模块导入主程序中。import 语句允许在当前运行的程序文件中使用模块中的代码。

## Python模块

 模块是一个 Python 文件，以 .py 结尾。模块中可以定义函数，类和变量，模块里也能包含可执行的代码。

1. 使用模块的好处：
   * 通过把函数存储在独立的文件中，可隐藏程序代码的细节，将重点放在程序的高层逻辑上。
   * 能让众多不同的程序中重用函数
   * 将函数存储在独立文件中后，可与其他程序员共享这个文件而不是整个程序
2. 自定义模块规范：
   * 模块名都采用小写格式，并在单词之间加上下划线
   * 每个模块也应该包含一个文档字符串

## Python标准库

Python 具有很强大的标准库（自有模块）。在Python被安装的时候，就有不少模块也随着安装到本地的计算机上了。这些东西就如同“电力”一样，让Python拥有了无限生机，能够轻而易举地免费使用很多模块。那些在安装Python时就默认已经安装好的模块被统称为“标准库”。 熟悉标准库可以让编程事半功倍。

Python3 的标准库模块有几百个，熟悉所有的模块不可能也没必要，只需要熟悉一些常用模块的常用功能，其他的模块在实际工作中用到哪个模块再去查找资料学习即可。

下面介绍几个常用的标准库:

* time模块：可以获取日期时间信息、处理时间
* random模块：可以生成随机数、随机字符
* sys模块：可以处理Python运行时配置以及资源，从而可以与当前程序之外的系统环境交互
* os模块：提供很多与操作系统相关的函数，可以处理文件和目录的操作

## 导入模块和指定别名

模块定义好后，可以使用import语句来引入模块

### 导入模块执行流程

在python中使用import语句导入模块时，python通过三个步骤来完成这个行为

1. 在python模块加载路径中查找相应的模块文件
2. 将模块文件编译成中间代码
3. 执行模块文件中的代码

* 在python中模块的导入动作只发生一次。也就是说当一个模块在一个文件中被导入过一次以后，当另外的文件继续需要导入这个模块时，python首先会在sys.modules这个变量中查出是否已经导入过这个模块，如果已经导入过则上面三个步骤不会执行，直接引用之前导入的内存中的内容。 
* 在步骤2中，python首先会查找对应模块的.pyc文件，看该文件的最后修改时间是否比对应的.py文件的走后修改时间早，如果遭遇.py文件的最后修改时间，则重新编译模块并重新生成字节码文件。注意，一个python程序的顶层文件不会生成.pyc文件。 
* 当python完成步骤2以后会执行python文件中的语句，以生成对应的对象属性，比如def语句生成该模块的一个函数属性等。因为这个特性，假如模块中有一个print语句 ， 那么， 当该模块被第一次加载的时候，该输出语句就会将内容输出，但是由于模块只能被import一次，所以，当模块第二次被加载的时候，上面这三个步骤都不会被执行，那么，这个输出不会再次出现。

### python模块搜索目录

python模块的搜索目录有下面四个部分组成

1. 程序home目录

   该目录的意思就是python应用程序的入口执行文件的存放目录

2. 环境变量PYTHONPATH中列出的目录

   通过设置该系统环境变量，可以指定python的额外搜索目录

3. python标准库目录

   python的标准库

4. python的.pth文件扩展额外的搜索目录

   该文件提供了一种扩展搜索目录的方式。在该文件中每一行表示一个扩展目录 

python程序在启动时按照上面的顺序依次依次合并起来称为python的库文件查找路径集合。所以当python在查找某一个模块时，首先查找home目录然后PYTHONPATH目录，然后标准库，然后.pth文件中提供的目录。 

python的模块搜索路径列表存放在sys.path变量总，可以通过输出该变量来查看当前模块搜索列表。也可以通过改改变该变量的值来动态修改python的搜索路径。

### .import导入整个模块

语法如下：

```python
import module1,module2,...moduleN
```

注意：module是模块名称，是不包含后缀.py

导入整个模块后，调用模块中的函数，语法如下：

```python
modul.functionname()
```

==注意：一个模块只会被导入一次，不管执行了多少次import，这样可以防止导入模块被一遍又一遍地执行==

![1565531550183](E:\Typora笔记\Python\assets\1565531550183.png)

![1565531562797](E:\Typora笔记\Python\assets\1565531562797.png)

![1565531999465](E:\Typora笔记\Python\assets\1565531999465.png)

### 导入模块中的特定函数

语法：

```python
from module import functionname1,functionname2...functionnameN
```

使用这种语法，调用函数只需指定函数名称即可。

```python
functionname1()
```

![1565571101191](E:\Typora笔记\Python\assets\1565571101191.png)

### 导入模块中的所有函数

语法：

```python
from module import *
```

使用这种语法，调用函数只需指定函数名称即可。

```python
functionname()
```

==注意：这种导入模块中所有函数的方法不建议过多使用==

![1565571262154](E:\Typora笔记\Python\assets\1565571262154.png)

### 使用as指定别名

如果要导入的函数名称与现有程序中的名称冲突或函数的名称太长，可使用as指定简单且独一无二的别名（相当于外号）。要给函数指定别名需要在导入时设置，也可以给模块指定别名

![1565571414871](E:\Typora笔记\Python\assets\1565571414871.png)

## 跨目录模块调用

在Python编程中，主程序（import module）与模块程序（module）在同一路径时是可以直接调用，但是实际项目开发中，所有文件不可能都在同一个目录中，也就不能再直接进行调用，

肯出现两种情况

### 第一种情况：主程序所在的目录是模块程序的父/祖辈目录

程序结构如下：主程序test1.py想要导入模块mod2

![1565571624537](E:\Typora笔记\Python\assets\1565571624537.png)

=="C:\\\test_import\\\src\\\lib"就是模块mod2的所在路径，需要注意Windows平台下的路径分割使用==

![1565571983220](E:\Typora笔记\Python\assets\1565571983220.png)

### 第二种情况：主程序导入它上层目录下的模块

项目结构如下：test2.py文件想要导入它上一级的mod1.py和上一级目录下的mod2.py文件

![1565572159975](E:\Typora笔记\Python\assets\1565572159975.png)

“.”表示当前目录，".."表示上一级目录也就是src

## 使用if\_\_name\_\_=='\_\_main\_\_'

一个Python的文件有两种使用的方法：第一是直接作为脚本执行；第二是import到其他的python脚本中被调用（模块重用）执行

### if\_\_name\_\_=='\_\_main\_\_'：的作用：

就是控制这两种情况执行代码的过程，在if\_\_name\_\_=='\_\_main\_\_'下的代码只有在第一种情况下（即文件作为脚本直接执行）才会被执行，而import到其他脚本中是不会被执行的

![1565572482342](E:\Typora笔记\Python\assets\1565572482342.png)

![1565572517830](E:\Typora笔记\Python\assets\1565572517830.png)

![1565572569020](E:\Typora笔记\Python\assets\1565572569020.png)

以上两次结果可以看出：直接执行某个.py文件的时候，该文件中那么”\_\_name\_\_ == '\_\_main\_\_'“是True,但是如果从另外一个.py文件通过import导入该文件的时候，这时\_\_name\_\_的值就是这个py文件的名字而不是\_\_main\_\_。这也就是 if \_\_name\_\_ = '\_\_main\_\_' 运行的原理。